#!/usr/bin/env python

import imaplib
import datetime
import logging

# Configuration
from Configuration import Configuration
from SavableLazyMail import SavableLazyMail
from Statistics import Statistics

CONFIG = Configuration()


#Load Hashcodes from File
DATABASE = set()
try:
    DATABASE_FILE = open(CONFIG.DATABASE_FILE_PATH, 'r')
except:
    DATABASE_FILE = open(CONFIG.DATABASE_FILE_PATH, 'w+')
    logging.info("Created New Database %s", CONFIG.DATABASE_FILE_PATH)

print "Loading Database...."
for line in DATABASE_FILE:
    DATABASE.add(line.replace('\n', ''))
logging.info("Loaded %i mail hash values from database", len(DATABASE))
STATS = Statistics(len(DATABASE))
DATABASE_FILE.close()
#Open Database-File for appending new HashCodes
DATABASE_FILE = open(CONFIG.DATABASE_FILE_PATH, 'a')

print "Connecting to Server..."
#Init Mail Connection
MAIL_CONNECTION = imaplib.IMAP4_SSL(CONFIG.MAIL_SERVER, CONFIG.MAIL_PORT) if CONFIG.MAIL_PORT else imaplib.IMAP4_SSL(CONFIG.MAIL_SERVER)
try:
    MAIL_CONNECTION.login(CONFIG.MAIL_USER, CONFIG.MAIL_PASSWORD)
    logging.info("Successfully connected to %s@%s", CONFIG.MAIL_USER, CONFIG.MAIL_SERVER)
except imaplib.IMAP4.error as e:
    print "Failed to connect"
    logging.error("Could not connect to %s@%s", CONFIG.MAIL_USER, CONFIG.MAIL_SERVER)
    logging.error("Reason: %s", e)
    exit(1)

print "Running Backup...."

#fetches the mailboxes/mailfolders lik "INBOX", "INBOX.Archives.2011" ('.' is separator)
# and gives it back as List
def fetchMailFolders():
    check, mailfolders_raw = MAIL_CONNECTION.list()
    mailfolders_parsed = []
    if check == 'OK':
        for folder_information in mailfolders_raw:
            #folder_information looks for example like:
            # (\HasNoChildren \UnMarked) "." "INBOX.Archives.2011"
            folder_information = folder_information.split('\"')
            #Some folders are only for navigation. They have the parameter (\Noselect)
            if "Noselect" not in folder_information[0]:
                for folder_name in folder_information[-1:0:-1]:
                    if folder_name:
                        while folder_name[0] == ' ':
                            folder_name = folder_name[1:]
                        mailfolders_parsed.append(folder_name)
                        break
    else:
        logging.critical("Could not load mailboxes: %s", check)
        exit(1)

    logging.debug("Mail Folders: %s", str(mailfolders_raw))
    return mailfolders_parsed


class DecodeError(Exception):
    pass


#Get Mail UIDs of mail_folder (in mailfolders_parsed)
#They are only unique in mail_folder and session!
def getUIDs(mail_folder):
    check, uids_raw = (None, None)
    if CONFIG.ONLY_LAST_X_DAYS:
        date = (datetime.date.today() - datetime.timedelta(CONFIG.ONLY_LAST_X_DAYS)).strftime("%d-%b-%Y")
        check, uids_raw = MAIL_CONNECTION.uid('search', None, '(SENTSINCE {date})'.format(date=date))
    else:
        check, uids_raw = MAIL_CONNECTION.uid('SEARCH', None, "ALL")

    if check == 'OK':
        MAIL_UIDs = uids_raw[0].split()
        return MAIL_UIDs
    else:
        logging.warning("Could not fetch UIDs for mailbox %s", mail_folder)
        return []


#adds a hashcode of a mail to the database such that it won't be fetched
# another time with all its attachments and co
# the hashcode is generated by getHashcode(uid)
def addHashCodeToDatabase(hashcode):
    DATABASE_FILE.write(hashcode + "\n")  #The \n has to be removed by reading
    DATABASE.add(hashcode)
    logging.debug("Added hashcode %s to database", hashcode)

#goes through all folders and checks the emails
for mailfolder in fetchMailFolders():
    try:
        #SPAM
        if mailfolder[-4:].lower() == 'spam':
            logging.info("Skip folder %s", mailfolder)
            continue

        folder_state = MAIL_CONNECTION.select(mailfolder, readonly=True)
        if folder_state[0] == 'OK':
            logging.info("Opened folder %s which contains %s mails", mailfolder, folder_state[1][0])
            for uid in getUIDs(mailfolder):
                mail = SavableLazyMail(CONFIG, MAIL_CONNECTION, uid, STATS)
                #Do not download the mail again, if you already have it in an previous run
                if not mail.getHashcode() in DATABASE:
                    if mail.saveMailToHardDisk():
                        addHashCodeToDatabase(mail.getHashcode())
                        STATS.email_successful_added()
                    else:
                        logging.error("Failed to save mail with hashcode %s", mail.getHashcode())
                        STATS.email_failed_to_add()

            MAIL_CONNECTION.close()
            logging.info("Closed folder %s", mailfolder)
        else:
            logging.error("Could not connect to mailbox %s because of %s", mailfolder, folder_state)

    except Exception as e:
        STATS.folder_failed_to_backup()
        logging.error("Failed to process mailbox %s because of %s", mailfolder, e)

#close the database file, so that all new hashcodes are saved
DATABASE_FILE.close()
#close the connection to the server
# (would be closed automatically after some time, but if there are too
#  many open connections, we maybe cannot login for some time)
MAIL_CONNECTION.logout()
logging.info("Closed connection to server")


#Stats
print STATS.toString()


